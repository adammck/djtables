django-tables
=============

this is a django app which renders querysets (and other sequences) into
semantic HTML tables. it provides an API for defining tables (similar to
django.forms), and template tags for rendering them.

unlike the other django-tables projects which i've encountered (and i
really would prefer to contribute to them, rather than building my own),
this app prioritizes drop-in convenience over flexibility.


defining your tables
--------------------

your table(s) can be defined anywhere, but i like to keep them in a
module named "tables.py" in your app. the most common use-case is to
display a list of the instances of a model. luckily, this is simple:

    class UsersTable(tables.ModelTable):
        class Meta:
            model = Human

...and that's it. additional columns can be defined in the class body
(like django models and forms), and the Meta (options) class can be used
to override the default behavior of the table. a more complex example:

    class UsersTable(tables.ModelTable):
        age = tables.BooleanColumn(lambda u: u.get_age())

        class Meta:
            model = User
            exclude = ["password"]
            order_by = "date_joined"
            order_dir = "desc"
            default_page = -1
            per_page = 20


instantiating a table in your view
----------------------------------

here's where it gets awesome. since the table class already knows which
model it's rendering, you don't need to fuss around extracting the GET
parameters, fetching a queryset, sorting it, and paginating it. just
instantiate the table, and it and pass it along to the template:

    def users_list(request):
        return render_to_response("template.html", {
            "users": UsersTable(request)
        })

sorting and pagination come for free. the following requests are all
handled in the way which (i hope) you would expect:

    /users
    /users?page=2
    /users?sort=username
    /users?sort=username;page=3

table options can also be set per-instance, by passing them to the
constructor. this is useful if the same table is rendered by multiple
views, or multiple tables are rendered by a single view. for example:

    def users_and_groups_lists(request):
        return render_to_response("template.html", {
            "users": UsersTable(request, prefix="usr-"),
            "groups": GroupsTable(request, prefix="grp-")
        })

both tables are rendered as usual, except the GET parameters used to
navigate them prefixed to avoid clashes. the following are valid:

    /whatever
    /whatever?usr-page=2
    /whatever?grp-sort=name
    /whatever?usr-sort=username;usr-page=3;grp-page=2


rendering a table in your template
----------------------------------

if you don't have any special requirements for the HTML output, tables
can render themselves like a django form:

    {{ users.as_html }}

this is just a short way of saying:

    <table class="users">
        {% table_cols users %}
        {% table_head users %}
        {% table_body users %}
        {% table_foot users %}
    </table>

any part of this template can be replaced with your own, without having
to replace the entire thing (which is quite large).
